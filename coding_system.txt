System:
    1. Read the problem twice and ensure 
        you get the input and desired result correctly
    2. Write a solution
    3. Calmly debug and walk-through your solution with inputs
        again and again, do not hit run button, this is a must
        check for syntax and logic flaws
    4. Confirm it works for obvious test-cases/new test-cases

    5. Think of improvements and edge cases
            EDGE-CASES:
                When input is empty
                When input is a single value
                Complex input
                Complex scenarios - which involves logic tweaking/improvements            
    6. Repeat, step 2-4

    7. Once Satisfied, Check for syntax errors or minute errors 
    8. Hit Run (Think of it this way, everytime you hit run
        you lose money or its very expensive)


Intuition:
- What is the meat of this problem?
    What is the problem testing for exactly?
- Where are the friction or resistance in grasping it
    slow down there & smoothen it out


--------------------------


SECTIONS (Tooling System) -> Similar To Mathematical Modelling
- Origin or a pattern / Reason behind a pattern
- Problem Idenitification
- Problem to code translation
- Systematic Code review
- Thinking about & Handling Edge cases 
- Done


---------

The Intuition System (Pattern Recognition)
- What is the core problem here?
- How does this map to a known pattern? (Divide & conquer, recursion, two-pointer, etc.)
- What are the constraints? (Time, space, bottlenecks)
- What’s making this problem hard? (Slow down, smooth it out)

--------------------------

Tooling System (Like Mathematical Modeling)
- Pattern Recognition – What known technique applies?
- Problem Identification – What’s the fundamental challenge?
- Problem to Code Translation – How do I express this cleanly in code?
- Systematic Code Review – Can I simplify, modularize, or optimize?
- Handling Edge Cases & Scaling – Will this work for extreme cases?